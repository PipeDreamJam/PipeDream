using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Rhythmify;

// Controls all pieces in a segment
public class PieceManager : _AbstractRhythmObject
{
    public List<GameObject> PieceList;
    public GameObject PiecePrefab;

    [Tooltip("Number of Pieces in the Segment")]
    public float numberOfPieces = 32;
    public int maxScale = 100;
    public float cubeSize = 1;
    public Vector3 CircleCenter;
    private float Radius;
    private Vector3 sumPos;
    private float sumRot;
    private int time_point, time_count;
    public int dist_point, dist_count;
    public int ring_limit, ring_count;
    private Vector3 last_pos, curr_pos;
    public static LinkedList<GameObject> tubes_list = new LinkedList<GameObject>();
    public float x = 1f;


    // Use this for initialization
    protected override void rhythmUpdate(int beat)
    {
        time_point = 0;
        last_pos = transform.position;
        Radius = cubeSize * numberOfPieces / Mathf.PI / 2;
        CircleCenter = new Vector3(0, 0, 0);
        sumPos = CircleCenter + new Vector3(Radius, 0, 0);
        PieceList = new List<GameObject>();

        foreach (GameObject go in tubes_list)
        {
            Vector3 new_pos = go.transform.position;
            new_pos.z += 5;
            go.transform.position = new_pos;
            curr_pos = new_pos;
        }

        if ((last_pos - curr_pos).magnitude > dist_point)
        {
            foreach (GameObject go_0 in tubes_list)
            {
                tubes_list.RemoveFirst();
                Destroy(go_0);
                break;
            }
            --ring_count;
        }

        if (ring_count < ring_limit)
        {
            Debug.Log("call ring");
            Create_Ring();
            ++ring_count;

        }
    }

    void Create_Ring()
    {
        Debug.Log("create ring");
        //for (int i = 0; i < numberOfPieces; i++)
        //{
            sumRot = 360 / numberOfPieces;
           PieceList.Add(PieceManager.Instantiate(PiecePrefab, sumPos, Quaternion.identity));
           sumPos = CircleCenter + new Vector3(Radius, 0, 0);
        //}

        for (int i = 0; i < numberOfPieces; i++)
        {
           
            PieceList[i].transform.RotateAround(CircleCenter, Vector3.up, sumRot * i + 1);
            PieceList[i].transform.localScale = new Vector3((AudioVisualizer.samples[i] * maxScale), 1, 1);
            Debug.Log("cubed");
            if (i == numberOfPieces + 1)
            {
                i = 0;
                PieceList[i].transform.localPosition = new Vector3(transform.position.x, x += 1f, transform.position.y);
                Debug.Log("ringed");

            }
            
        }

        //for (int i = 0; i < numberOfPieces; i++)
        //{

        //    PieceList[i].transform.localScale = new Vector3((AudioVisualizer.samples[i] * maxScale), 1, 1);
        //}

        //for (int i = 0; i < numberOfPieces; i++)
        //{
        //    PieceList[i].transform.localPosition = new Vector3(0, i, 0);  

        //}
    }



    protected virtual void asyncUpdate() { }
    protected virtual void init() { }
    protected bool onBeat()
    {
        return true;
    }



}
